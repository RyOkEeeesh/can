{
  "version": 3,
  "sources": ["../../three-csg-ts/lib/esm/NBuf.js", "../../three-csg-ts/lib/esm/Node.js", "../../three-csg-ts/lib/esm/Vector.js", "../../three-csg-ts/lib/esm/Plane.js", "../../three-csg-ts/lib/esm/Polygon.js", "../../three-csg-ts/lib/esm/Vertex.js", "../../three-csg-ts/lib/esm/CSG.js"],
  "sourcesContent": ["export class NBuf3 {\r\n    constructor(ct) {\r\n        this.top = 0;\r\n        this.array = new Float32Array(ct);\r\n    }\r\n    write(v) {\r\n        this.array[this.top++] = v.x;\r\n        this.array[this.top++] = v.y;\r\n        this.array[this.top++] = v.z;\r\n    }\r\n}\r\nexport class NBuf2 {\r\n    constructor(ct) {\r\n        this.top = 0;\r\n        this.array = new Float32Array(ct);\r\n    }\r\n    write(v) {\r\n        this.array[this.top++] = v.x;\r\n        this.array[this.top++] = v.y;\r\n    }\r\n}\r\n", "/**\r\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\r\n * by picking a polygon to split along. That polygon (and all other coplanar\r\n * polygons) are added directly to that node and the other polygons are added to\r\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\r\n * no distinction between internal and leaf nodes.\r\n */\r\nexport class Node {\r\n    constructor(polygons) {\r\n        this.plane = null;\r\n        this.front = null;\r\n        this.back = null;\r\n        this.polygons = [];\r\n        if (polygons)\r\n            this.build(polygons);\r\n    }\r\n    clone() {\r\n        const node = new Node();\r\n        node.plane = this.plane && this.plane.clone();\r\n        node.front = this.front && this.front.clone();\r\n        node.back = this.back && this.back.clone();\r\n        node.polygons = this.polygons.map((p) => p.clone());\r\n        return node;\r\n    }\r\n    // Convert solid space to empty space and empty space to solid space.\r\n    invert() {\r\n        for (let i = 0; i < this.polygons.length; i++)\r\n            this.polygons[i].flip();\r\n        this.plane && this.plane.flip();\r\n        this.front && this.front.invert();\r\n        this.back && this.back.invert();\r\n        const temp = this.front;\r\n        this.front = this.back;\r\n        this.back = temp;\r\n    }\r\n    // Recursively remove all polygons in `polygons` that are inside this BSP\r\n    // tree.\r\n    clipPolygons(polygons) {\r\n        if (!this.plane)\r\n            return polygons.slice();\r\n        let front = new Array(), back = new Array();\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this.plane.splitPolygon(polygons[i], front, back, front, back);\r\n        }\r\n        if (this.front)\r\n            front = this.front.clipPolygons(front);\r\n        this.back ? (back = this.back.clipPolygons(back)) : (back = []);\r\n        return front.concat(back);\r\n    }\r\n    // Remove all polygons in this BSP tree that are inside the other BSP tree\r\n    // `bsp`.\r\n    clipTo(bsp) {\r\n        this.polygons = bsp.clipPolygons(this.polygons);\r\n        if (this.front)\r\n            this.front.clipTo(bsp);\r\n        if (this.back)\r\n            this.back.clipTo(bsp);\r\n    }\r\n    // Return a list of all polygons in this BSP tree.\r\n    allPolygons() {\r\n        let polygons = this.polygons.slice();\r\n        if (this.front)\r\n            polygons = polygons.concat(this.front.allPolygons());\r\n        if (this.back)\r\n            polygons = polygons.concat(this.back.allPolygons());\r\n        return polygons;\r\n    }\r\n    // Build a BSP tree out of `polygons`. When called on an existing tree, the\r\n    // new polygons are filtered down to the bottom of the tree and become new\r\n    // nodes there. Each set of polygons is partitioned using the first polygon\r\n    // (no heuristic is used to pick a good split).\r\n    build(polygons) {\r\n        if (!polygons.length)\r\n            return;\r\n        if (!this.plane)\r\n            this.plane = polygons[0].plane.clone();\r\n        const front = [], back = [];\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\r\n        }\r\n        if (front.length) {\r\n            if (!this.front)\r\n                this.front = new Node();\r\n            this.front.build(front);\r\n        }\r\n        if (back.length) {\r\n            if (!this.back)\r\n                this.back = new Node();\r\n            this.back.build(back);\r\n        }\r\n    }\r\n}\r\n", "import { Vector3 } from 'three';\r\n/**\r\n * Represents a 3D vector.\r\n */\r\nexport class Vector {\r\n    constructor(x = 0, y = 0, z = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    copy(v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n        this.z = v.z;\r\n        return this;\r\n    }\r\n    clone() {\r\n        return new Vector(this.x, this.y, this.z);\r\n    }\r\n    negate() {\r\n        this.x *= -1;\r\n        this.y *= -1;\r\n        this.z *= -1;\r\n        return this;\r\n    }\r\n    add(a) {\r\n        this.x += a.x;\r\n        this.y += a.y;\r\n        this.z += a.z;\r\n        return this;\r\n    }\r\n    sub(a) {\r\n        this.x -= a.x;\r\n        this.y -= a.y;\r\n        this.z -= a.z;\r\n        return this;\r\n    }\r\n    times(a) {\r\n        this.x *= a;\r\n        this.y *= a;\r\n        this.z *= a;\r\n        return this;\r\n    }\r\n    dividedBy(a) {\r\n        this.x /= a;\r\n        this.y /= a;\r\n        this.z /= a;\r\n        return this;\r\n    }\r\n    lerp(a, t) {\r\n        return this.add(new Vector().copy(a).sub(this).times(t));\r\n    }\r\n    unit() {\r\n        return this.dividedBy(this.length());\r\n    }\r\n    length() {\r\n        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));\r\n    }\r\n    normalize() {\r\n        return this.unit();\r\n    }\r\n    cross(b) {\r\n        const a = this.clone();\r\n        const ax = a.x, ay = a.y, az = a.z;\r\n        const bx = b.x, by = b.y, bz = b.z;\r\n        this.x = ay * bz - az * by;\r\n        this.y = az * bx - ax * bz;\r\n        this.z = ax * by - ay * bx;\r\n        return this;\r\n    }\r\n    dot(b) {\r\n        return this.x * b.x + this.y * b.y + this.z * b.z;\r\n    }\r\n    toVector3() {\r\n        return new Vector3(this.x, this.y, this.z);\r\n    }\r\n}\r\n", "import { Polygon } from './Polygon';\r\nimport { Vector } from './Vector';\r\n/**\r\n * Represents a plane in 3D space.\r\n */\r\nexport class Plane {\r\n    constructor(normal, w) {\r\n        this.normal = normal;\r\n        this.w = w;\r\n        this.normal = normal;\r\n        this.w = w;\r\n    }\r\n    clone() {\r\n        return new Plane(this.normal.clone(), this.w);\r\n    }\r\n    flip() {\r\n        this.normal.negate();\r\n        this.w = -this.w;\r\n    }\r\n    // Split `polygon` by this plane if needed, then put the polygon or polygon\r\n    // fragments in the appropriate lists. Coplanar polygons go into either\r\n    // `coplanarFront` or `coplanarBack` depending on their orientation with\r\n    // respect to this plane. Polygons in front or in back of this plane go into\r\n    // either `front` or `back`.\r\n    splitPolygon(polygon, coplanarFront, coplanarBack, front, back) {\r\n        const COPLANAR = 0;\r\n        const FRONT = 1;\r\n        const BACK = 2;\r\n        const SPANNING = 3;\r\n        // Classify each point as well as the entire polygon into one of the above\r\n        // four classes.\r\n        let polygonType = 0;\r\n        const types = [];\r\n        for (let i = 0; i < polygon.vertices.length; i++) {\r\n            const t = this.normal.dot(polygon.vertices[i].pos) - this.w;\r\n            const type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\r\n            polygonType |= type;\r\n            types.push(type);\r\n        }\r\n        // Put the polygon in the correct list, splitting it when necessary.\r\n        switch (polygonType) {\r\n            case COPLANAR:\r\n                (this.normal.dot(polygon.plane.normal) > 0\r\n                    ? coplanarFront\r\n                    : coplanarBack).push(polygon);\r\n                break;\r\n            case FRONT:\r\n                front.push(polygon);\r\n                break;\r\n            case BACK:\r\n                back.push(polygon);\r\n                break;\r\n            case SPANNING: {\r\n                const f = [], b = [];\r\n                for (let i = 0; i < polygon.vertices.length; i++) {\r\n                    const j = (i + 1) % polygon.vertices.length;\r\n                    const ti = types[i], tj = types[j];\r\n                    const vi = polygon.vertices[i], vj = polygon.vertices[j];\r\n                    if (ti != BACK)\r\n                        f.push(vi);\r\n                    if (ti != FRONT)\r\n                        b.push(ti != BACK ? vi.clone() : vi);\r\n                    if ((ti | tj) == SPANNING) {\r\n                        const t = (this.w - this.normal.dot(vi.pos)) /\r\n                            this.normal.dot(new Vector().copy(vj.pos).sub(vi.pos));\r\n                        const v = vi.interpolate(vj, t);\r\n                        f.push(v);\r\n                        b.push(v.clone());\r\n                    }\r\n                }\r\n                if (f.length >= 3)\r\n                    front.push(new Polygon(f, polygon.shared));\r\n                if (b.length >= 3)\r\n                    back.push(new Polygon(b, polygon.shared));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    static fromPoints(a, b, c) {\r\n        const n = new Vector()\r\n            .copy(b)\r\n            .sub(a)\r\n            .cross(new Vector().copy(c).sub(a))\r\n            .normalize();\r\n        return new Plane(n.clone(), n.dot(a));\r\n    }\r\n}\r\nPlane.EPSILON = 1e-5;\r\n", "import { Plane } from './Plane';\r\n/**\r\n * Represents a convex polygon. The vertices used to initialize a polygon must\r\n * be coplanar and form a convex loop. They do not have to be `Vertex`\r\n * instances but they must behave similarly (duck typing can be used for\r\n * customization).\r\n *\r\n * Each convex polygon has a `shared` property, which is shared between all\r\n * polygons that are clones of each other or were split from the same polygon.\r\n * This can be used to define per-polygon properties (such as surface color).\r\n */\r\nexport class Polygon {\r\n    constructor(vertices, shared) {\r\n        this.vertices = vertices;\r\n        this.shared = shared;\r\n        this.plane = Plane.fromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\r\n    }\r\n    clone() {\r\n        return new Polygon(this.vertices.map((v) => v.clone()), this.shared);\r\n    }\r\n    flip() {\r\n        this.vertices.reverse().map((v) => v.flip());\r\n        this.plane.flip();\r\n    }\r\n}\r\n", "import { Vector } from './Vector';\r\n/**\r\n * Represents a vertex of a polygon. Use your own vertex class instead of this\r\n * one to provide additional features like texture coordinates and vertex\r\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\r\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\r\n * defined by `CSG.Vertex`. This class provides `normal` so convenience\r\n * functions like `CSG.sphere()` can return a smooth vertex normal, but `normal`\r\n * is not used anywhere else.\r\n */\r\nexport class Vertex {\r\n    constructor(pos, normal, uv, color) {\r\n        this.pos = new Vector().copy(pos);\r\n        this.normal = new Vector().copy(normal);\r\n        this.uv = new Vector().copy(uv);\r\n        this.uv.z = 0;\r\n        color && (this.color = new Vector().copy(color));\r\n    }\r\n    clone() {\r\n        return new Vertex(this.pos, this.normal, this.uv, this.color);\r\n    }\r\n    // Invert all orientation-specific data (e.g. vertex normal). Called when the\r\n    // orientation of a polygon is flipped.\r\n    flip() {\r\n        this.normal.negate();\r\n    }\r\n    // Create a new vertex between this vertex and `other` by linearly\r\n    // interpolating all properties using a parameter of `t`. Subclasses should\r\n    // override this to interpolate additional properties.\r\n    interpolate(other, t) {\r\n        return new Vertex(this.pos.clone().lerp(other.pos, t), this.normal.clone().lerp(other.normal, t), this.uv.clone().lerp(other.uv, t), this.color && other.color && this.color.clone().lerp(other.color, t));\r\n    }\r\n}\r\n", "import { BufferAttribute, BufferGeometry, Matrix3, Matrix4, Mesh, Vector3, } from 'three';\r\nimport { NBuf2, NBuf3 } from './NBuf';\r\nimport { Node } from './Node';\r\nimport { Polygon } from './Polygon';\r\nimport { Vector } from './Vector';\r\nimport { Vertex } from './Vertex';\r\n/**\r\n * Holds a binary space partition tree representing a 3D solid. Two solids can\r\n * be combined using the `union()`, `subtract()`, and `intersect()` methods.\r\n */\r\nexport class CSG {\r\n    constructor() {\r\n        this.polygons = [];\r\n    }\r\n    static fromPolygons(polygons) {\r\n        const csg = new CSG();\r\n        csg.polygons = polygons;\r\n        return csg;\r\n    }\r\n    static fromGeometry(geom, objectIndex) {\r\n        let polys = [];\r\n        const posattr = geom.attributes.position;\r\n        const normalattr = geom.attributes.normal;\r\n        const uvattr = geom.attributes.uv;\r\n        const colorattr = geom.attributes.color;\r\n        const grps = geom.groups;\r\n        let index;\r\n        if (geom.index) {\r\n            index = geom.index.array;\r\n        }\r\n        else {\r\n            index = new Uint16Array((posattr.array.length / posattr.itemSize) | 0);\r\n            for (let i = 0; i < index.length; i++)\r\n                index[i] = i;\r\n        }\r\n        const triCount = (index.length / 3) | 0;\r\n        polys = new Array(triCount);\r\n        for (let i = 0, pli = 0, l = index.length; i < l; i += 3, pli++) {\r\n            const vertices = new Array(3);\r\n            for (let j = 0; j < 3; j++) {\r\n                const vi = index[i + j];\r\n                const vp = vi * 3;\r\n                const vt = vi * 2;\r\n                const x = posattr.array[vp];\r\n                const y = posattr.array[vp + 1];\r\n                const z = posattr.array[vp + 2];\r\n                const nx = normalattr.array[vp];\r\n                const ny = normalattr.array[vp + 1];\r\n                const nz = normalattr.array[vp + 2];\r\n                const u = uvattr === null || uvattr === void 0 ? void 0 : uvattr.array[vt];\r\n                const v = uvattr === null || uvattr === void 0 ? void 0 : uvattr.array[vt + 1];\r\n                vertices[j] = new Vertex(new Vector(x, y, z), new Vector(nx, ny, nz), new Vector(u, v, 0), colorattr &&\r\n                    new Vector(colorattr.array[vp], colorattr.array[vp + 1], colorattr.array[vp + 2]));\r\n            }\r\n            if (objectIndex === undefined && grps && grps.length > 0) {\r\n                for (const grp of grps) {\r\n                    if (i >= grp.start && i < grp.start + grp.count) {\r\n                        polys[pli] = new Polygon(vertices, grp.materialIndex);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                polys[pli] = new Polygon(vertices, objectIndex);\r\n            }\r\n        }\r\n        return CSG.fromPolygons(polys.filter((p) => !Number.isNaN(p.plane.normal.x)));\r\n    }\r\n    static toGeometry(csg, toMatrix) {\r\n        let triCount = 0;\r\n        const ps = csg.polygons;\r\n        for (const p of ps) {\r\n            triCount += p.vertices.length - 2;\r\n        }\r\n        const geom = new BufferGeometry();\r\n        const vertices = new NBuf3(triCount * 3 * 3);\r\n        const normals = new NBuf3(triCount * 3 * 3);\r\n        const uvs = new NBuf2(triCount * 2 * 3);\r\n        let colors;\r\n        const grps = [];\r\n        const dgrp = [];\r\n        for (const p of ps) {\r\n            const pvs = p.vertices;\r\n            const pvlen = pvs.length;\r\n            if (p.shared !== undefined) {\r\n                if (!grps[p.shared])\r\n                    grps[p.shared] = [];\r\n            }\r\n            if (pvlen && pvs[0].color !== undefined) {\r\n                if (!colors)\r\n                    colors = new NBuf3(triCount * 3 * 3);\r\n            }\r\n            for (let j = 3; j <= pvlen; j++) {\r\n                const grp = p.shared === undefined ? dgrp : grps[p.shared];\r\n                grp.push(vertices.top / 3, vertices.top / 3 + 1, vertices.top / 3 + 2);\r\n                vertices.write(pvs[0].pos);\r\n                vertices.write(pvs[j - 2].pos);\r\n                vertices.write(pvs[j - 1].pos);\r\n                normals.write(pvs[0].normal);\r\n                normals.write(pvs[j - 2].normal);\r\n                normals.write(pvs[j - 1].normal);\r\n                if (uvs) {\r\n                    uvs.write(pvs[0].uv);\r\n                    uvs.write(pvs[j - 2].uv);\r\n                    uvs.write(pvs[j - 1].uv);\r\n                }\r\n                if (colors) {\r\n                    colors.write(pvs[0].color);\r\n                    colors.write(pvs[j - 2].color);\r\n                    colors.write(pvs[j - 1].color);\r\n                }\r\n            }\r\n        }\r\n        geom.setAttribute('position', new BufferAttribute(vertices.array, 3));\r\n        geom.setAttribute('normal', new BufferAttribute(normals.array, 3));\r\n        uvs && geom.setAttribute('uv', new BufferAttribute(uvs.array, 2));\r\n        colors && geom.setAttribute('color', new BufferAttribute(colors.array, 3));\r\n        for (let gi = 0; gi < grps.length; gi++) {\r\n            if (grps[gi] === undefined) {\r\n                grps[gi] = [];\r\n            }\r\n        }\r\n        if (grps.length) {\r\n            let index = [];\r\n            let gbase = 0;\r\n            for (let gi = 0; gi < grps.length; gi++) {\r\n                geom.addGroup(gbase, grps[gi].length, gi);\r\n                gbase += grps[gi].length;\r\n                index = index.concat(grps[gi]);\r\n            }\r\n            geom.addGroup(gbase, dgrp.length, grps.length);\r\n            index = index.concat(dgrp);\r\n            geom.setIndex(index);\r\n        }\r\n        const inv = new Matrix4().copy(toMatrix).invert();\r\n        geom.applyMatrix4(inv);\r\n        geom.computeBoundingSphere();\r\n        geom.computeBoundingBox();\r\n        return geom;\r\n    }\r\n    static fromMesh(mesh, objectIndex) {\r\n        const csg = CSG.fromGeometry(mesh.geometry, objectIndex);\r\n        const ttvv0 = new Vector3();\r\n        const tmpm3 = new Matrix3();\r\n        tmpm3.getNormalMatrix(mesh.matrix);\r\n        for (let i = 0; i < csg.polygons.length; i++) {\r\n            const p = csg.polygons[i];\r\n            for (let j = 0; j < p.vertices.length; j++) {\r\n                const v = p.vertices[j];\r\n                v.pos.copy(ttvv0.copy(v.pos.toVector3()).applyMatrix4(mesh.matrix));\r\n                v.normal.copy(ttvv0.copy(v.normal.toVector3()).applyMatrix3(tmpm3));\r\n            }\r\n        }\r\n        return csg;\r\n    }\r\n    static toMesh(csg, toMatrix, toMaterial) {\r\n        const geom = CSG.toGeometry(csg, toMatrix);\r\n        const m = new Mesh(geom, toMaterial);\r\n        m.matrix.copy(toMatrix);\r\n        m.matrix.decompose(m.position, m.quaternion, m.scale);\r\n        m.rotation.setFromQuaternion(m.quaternion);\r\n        m.updateMatrixWorld();\r\n        m.castShadow = m.receiveShadow = true;\r\n        return m;\r\n    }\r\n    static union(meshA, meshB) {\r\n        const csgA = CSG.fromMesh(meshA);\r\n        const csgB = CSG.fromMesh(meshB);\r\n        return CSG.toMesh(csgA.union(csgB), meshA.matrix, meshA.material);\r\n    }\r\n    static subtract(meshA, meshB) {\r\n        const csgA = CSG.fromMesh(meshA);\r\n        const csgB = CSG.fromMesh(meshB);\r\n        return CSG.toMesh(csgA.subtract(csgB), meshA.matrix, meshA.material);\r\n    }\r\n    static intersect(meshA, meshB) {\r\n        const csgA = CSG.fromMesh(meshA);\r\n        const csgB = CSG.fromMesh(meshB);\r\n        return CSG.toMesh(csgA.intersect(csgB), meshA.matrix, meshA.material);\r\n    }\r\n    clone() {\r\n        const csg = new CSG();\r\n        csg.polygons = this.polygons\r\n            .map((p) => p.clone())\r\n            .filter((p) => Number.isFinite(p.plane.w));\r\n        return csg;\r\n    }\r\n    toPolygons() {\r\n        return this.polygons;\r\n    }\r\n    union(csg) {\r\n        const a = new Node(this.clone().polygons);\r\n        const b = new Node(csg.clone().polygons);\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        return CSG.fromPolygons(a.allPolygons());\r\n    }\r\n    subtract(csg) {\r\n        const a = new Node(this.clone().polygons);\r\n        const b = new Node(csg.clone().polygons);\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG.fromPolygons(a.allPolygons());\r\n    }\r\n    intersect(csg) {\r\n        const a = new Node(this.clone().polygons);\r\n        const b = new Node(csg.clone().polygons);\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG.fromPolygons(a.allPolygons());\r\n    }\r\n    // Return a new CSG solid with solid and empty space switched. This solid is\r\n    // not modified.\r\n    inverse() {\r\n        const csg = this.clone();\r\n        for (const p of csg.polygons) {\r\n            p.flip();\r\n        }\r\n        return csg;\r\n    }\r\n    toMesh(toMatrix, toMaterial) {\r\n        return CSG.toMesh(this, toMatrix, toMaterial);\r\n    }\r\n    toGeometry(toMatrix) {\r\n        return CSG.toGeometry(this, toMatrix);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
